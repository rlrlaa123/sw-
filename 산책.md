# 산책


직원들의 건강을 위해 점심 식사 후 산책을 하기로 했다.

산책로는 좁기 때문에 다른 사람을 추월할 수 없어서 그룹이 만들어지는데 몇 개의 그룹이 만들어 지는지 알아보려고 한다.




### [요구사항]


모든 직원이 동시에 출발하고 출발 위치는 직원마다 다르며, 산책 속도는 직원 별로 같거나 다를 수 있다. 산책은 총 T분 동안 진행되는데 산책로가 좁기 때문에 다른 사람을 추월할 수 없어서 그룹이 형성된다.




### 값 범위

1. 직원 수 N은 1 이상 100,000 이하

2. 산책 시간 T는 1 이상 1,000,000,000 분 이하

3. 직원 i번의 출발 위치 Pi는 0 이상 1,000,000,000 이하

4. 직원 i번의 산책 속도 Si는 0 이상 1,000,000,000 이하




산책로가 하나 밖에 없고 좁아서 다른 직원을 추월할 수 없다.

그래서 더 빠른 직원이 다른 직원을 따라 잡았을 때, 추월하지 못하고 같은 속도로 산책할 수 밖에 없다(이때, 직원들이 한 줄로 길게 늘어지게 되지만 그냥 같은 위치에 있는 것으로 취급함, 아래 설명 참조). 즉, 그룹이 만들어 지게 된다.

T분 후에 같은 위치에 있어도 같은 그룹이다.




입력 1에서 5명의 직원이 3분 동안 산책을 하면,

그룹 1은 0번 직원으로 3위치에 있으며,

그룹 2는 1번 직원으로 7위치에 있고,

그룹 3은 2, 3, 4 번 직원으로 9위치에 있다.

2번 직원은 2 + 3 * 3 = 11 위치까지 갈 수 있지만 앞 직원이 9위치까지만 갈 수 있으므로 같은 그룹이 된다.




직원 수 N과 산책 시간 T, 그리고 각 직원의 출발 위치와 속도가 주어졌을 때,

T분 후에 형성되는 그룹의 수를 계산하시오




### [입력형식]


첫 번째 줄에는 직원의 수 N과 산책시간 T가 공백으로 구분되어 입력

두 번째 줄에는 N줄에 걸쳐 각 직원의 출발 위치 Pi와 산책 속도 Si가 공백으로 구분되어 입력(출발 위치 오름차순으로 입력)




### [출력 형식]

T분 후 형성되는 그룹의 수를 출력


### 풀이

* 포인트 1
  * 출발점 + 산책시간 * 속도 공식을 찾는다.
* 포인트 2
  * 뒤의 사람보다 결과값이 커질경우, 뒷 사람의 값으로 결과 값을 바꿔준다.
* 포인트 3
  * 그룹별로 어떻게 카운트할지 방법을 찾는다.
  * 풀이답안의 경우 stack에 결과값을 넣고 더 작아진 값을 이전 스택값에 넣고 마지막에 top의 값을 그룹으로 봤다.
  * 내가 고안한 방법의 경우 결과값들을 배열에 넣고, 다른 값들만 카운트해주는 것이다.
  
### 모범답안
```
  #include <stdio.h>

  int N;
  int T;
  int P[100000 + 10];
  int S[100000 + 10];

  long long stack[100000 + 10];

  void Input_Data(void){
    int i;
    scanf("%d %d", &N, &T);
    for (i = 0; i < N; i++){
      scanf("%d %d", &P[i], &S[i]);
    }
  }

  int solve(void){
    int i, sp = 0;
    long long pos;
    for(i = 0; i < N; i++){
      pos = P[i] + (long long)T * S[i];
  //		while ((sp > 0) && (stack[sp] >= pos)) {
  //			sp--;
  //		}
      for( ; (sp > 0) && (stack[sp] >= pos) ; sp--);
      stack[++sp] = pos;
    }
    return sp;
  }

  int main(void){
    int ans = -1;
    Input_Data();
    ans = solve();
    printf("%d\n", ans);
    return 0;
  }
 ```
